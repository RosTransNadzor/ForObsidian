[[Конвейер фильтров]]

- Простой фильтр для проверки доступа используя фильтр ресурсов
- (проверяет если у данного пользователя права)
```cs
public class FeatureEnabledAttribute : Attribute, IResourceFilter
{
	//переменная доступа
	public bool IsEnabled { get; set; }
	public FeatureEnabledAttribute(bool isEn)
	{
		IsEnabled = isEn
	}
	// до выполнения контроллера
	public void OnResourceExecuting(
	ResourceExecutingContext context)
	{
		if (!IsEnabled)
		{
			// возвращение ошибки доступа
			context.Result = new BadRequestResult();
		}
	}
	public void OnResourceExecuted(
	ResourceExecutedContext context)
	{ }
}
```
- Использование
```cs
[FeatureEnabled(IsEnabled = true)]
public class RecipeApiController : ControllerBase{}
```
- Фильтр действий
```cs
public class EnsureRecipeExistsAtribute : ActionFilterAttribute
{
	// до выполнения действия но после привязки
	public override void OnActionExecuting(
	ActionExecutingContext context)
	{
		// получение сервиса
		var service = (RecipeService)context.HttpContext
		.RequestServices.GetService(typeof(RecipeService));
		// получение агрумента
		var recipeId = (int)context.ActionArguments["id"];
		if (!service.DoesRecipeExist(recipeId))
		{
			context.Result = new NotFoundResult();
		}
	}
}
```
- Тот же самый обработчик но в Razor pags
```cs
public class PageEnsureRecipeExistsAtribute : Attribute, IPageFilter
{
	// после выбора обработчика, но до привязки
	public void OnPageHandlerSelected(
	PageHandlerSelectedContext context)
	{ }
	// после привязки но до действия(чаще всего)
	public void OnPageHandlerExecuting(
	PageHandlerExecutingContext context)
	{
		var service = (RecipeService)context.HttpContext
		.RequestServices.GetService(typeof(RecipeService));
		var recipeId = (int)context.HandlerArguments["id"];
		if (!service.DoesRecipeExist(recipeId))
		{
			context.Result = new NotFoundResult();
		}
	}
	// после обработчика
	public void OnPageHandlerExecuted( PageHandlerExecutedContext context) { }
}
```
- Фильтр обработки ошибок
```cs
public class HandleExceptionAttribute : ExceptionFilterAttribute
{
	// вызывается при возникновении любой ошибки
	public override void OnException(ExceptionContext context)
	{
		var error = new ProblemDetails
		{
			Title = "An error occurred",
			Detail = context.Exception.Message,
			Status = 500,
			Type = "https://httpstatuses.com/500"
		};
		context.Result = new ObjectResult(error)
		{
			StatusCode = 500
		};
		// обязательная строка для остановки конвейера 
		context.ExceptionHandled = true;
	}
}
```
- Фильтры результата
```cs
public class AddLastModifedHeaderAttribute : ResultFilterAttribute
{
	// выполняется после действия
	public override void OnResultExecuting(
	ResultExecutingContext context)
	{
		if (context.Result is OkObjectResult result
		&& result.Value is RecipeDetailViewModel detail)
		{
			var viewModelDate = detail.LastModified;
			context.HttpContext.Response
			.GetTypedHeaders().LastModified = viewModelDate;
		}
	}
}
```
- Особые фильтры результата
	- ProducesAttribute – приводит к тому, что результат веб-API будет сериализован в определенный выходной формат. Например, декорируя метод действия [Produces("application/xml")] этим фильтром, вы заставляете форматеры попытаться отформатировать ответ в виде XML, даже если в заголовке клиента Accept этого формата нет; 
	- FormatFilterAttribute  – декорируя метод действия этим фильтром, вы даете форматеру указание искать значение маршрута или параметр строки запроса, format, и  использовать его для определения выходного формата. Например, можно вызвать /api/ recipe/11?format=json, а FormatFilter отформатирует ответ в виде JSON или вызовите api/recipe/11?Format=xml  – и  получите ответ в формате XML1 .
	- [[Formatter]]
- Прерывание фильтров

![[прерывание фильтров.png]]

