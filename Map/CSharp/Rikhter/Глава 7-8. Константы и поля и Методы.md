[[Книга CLR via Csharp]]

- Размещение констант
	- Константа существует во время компиляции, но не во время выполнения
	- Поскольку значение константы внедряется прямо в код, в период выполнения память для констант не выделяется
- Отсутствие вызова конструктура
	- В редких ситуациях экземпляр типа может создаваться без вызова конструктора экземпляров. В частности, метод MemberwiseClone объекта Object выделяет память, инициализирует служебные поля объекта, а затем копирует байты исходного объекта в область памяти, выделенную для нового объекта.
	- Кроме того, конструктор обычно не вызывается при десериализации объекта.
- Конструктор у struct
	- Если переопределить конструктор у структуры без параметров,то без его явного вызова по умолчанию он вызываться не будет 
	- `Вообще говоря, CLR позволяет программистам определять конструкторы для значимых типов, но эти конструкторы выполняются лишь при наличии кода, явно вызывающего один из них` - Цитата из книги 
		```cs
		public struct Some  
		{  
			// private int _value = 5; - так тоже не работает
		    private int _value;  
		    public Some()  
		    {        _value = 5;  
		    }  
		    public  int GetValue() => _value;  
		}  
		  
		public class Another  
		{  
		    public Some s;  
		}  
		  
		static void Main(string[] args)  
		{  
		    Another an = new Another();  
		    Console.WriteLine(an.s.GetValue()); // 0 вместо 5  
		}
		```
- Статические конструктуры
	- Они вызываются при первом обращении к статическим данным
- 