<span style="color:HotPink;font-weight:bold;">IAsyncEnumerable</span>

- IAsyncEnumerable 
	- IAsyncEnumerable тоже возвращает несколько элементов асинхронно
	- Потребление IAsyncEnumerable очень похоже на потребление IEnumerable
- Потребление IAsyncEnumerable
	- проще делать с помощью await foreach
	 - await foreach с избеганием SyncronizationContext 
	  ```cs
		public static async Task MainAsync()  
		{  
			// избегаем продолжение в контексте
			await foreach (int num in Method().ConfigureAwait(false))  
			{        
				Console.WriteLine(Thread.CurrentThread.ManagedThreadId);  
			}
		}  
		private static async IAsyncEnumerable<int> Method()  
		{  
			for (int i = 0; i < 10; i++)  
			{
				// избегаем продолжение в контексте        
				await Task.Delay(100).ConfigureAwait(false);  
			    Console.WriteLine($"method : {Thread.CurrentThread.ManagedThreadId}");  
			    yield return i;  
			}
		}
		```
- Linq to IAsyncEnumerable
	- Операторы для этого находятся в библиотеке System.Linq.Async
	- Можно выделить WhereAwait,SelectAwait
	- Которые можно использовать и для обычных коллекций но их снача нужно преобразовать в IAsyncEnumerable с помощью метода ToAsyncEnumerable
- Приостановка перечисления
	- Если нужно просто приостановить перечисление можно использовать оператор break в await foreach цикле 
		```cs
		 await foreach (int result in SlowRange())
		 { 
			 Console.WriteLine(result); 
			 if (result >= 8) break; 
		}
		```
- Передача токена отмены методу с возвращением IAsyncEnumerable
	- Для перехвата отмены необходимо весь await foreach обернуть в try catch
	- Для этого необходимо передать токен с определенным аттрибутом
		```cs
		private static async IAsyncEnumerable<int> Method  
		    ([EnumeratorCancellation] CancellationToken token = default)  
		{  
		    for (int i = 0; i < 10; i++)  
		    {       
			    await Task.Delay(100,token);  
		        yield return i;  
			}
		}
		```
- Передача токена отмены готовой IAsyncEnumerable 
	```cs
	IAsyncEnumerable<int> asyncEn = ...
	try  
	{  
	    await foreach (int el in asyncEn.WithCancellation(cts.Token))  
	    {        
		    Console.WriteLine(el);  
	    }
	}  
	catch (OperationCanceledException canceledException)  
	{  
	    Console.WriteLine(canceledException.Message);  
	}
	```




