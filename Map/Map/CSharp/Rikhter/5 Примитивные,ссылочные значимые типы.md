[[Книга CLR via Csharp]]

- Перечисления и структуры
	- Они являются значимымми типами
	- Все структуры являются производными от System.ValueType
- Структуры
	- Из-за производительности лучше переопределять Equals и GetHashCode
- StructLayout
	- Для ссылочных типов LayoutKind.Auto, для структур LayoutKind.Sequential по умолчанию
	- Однако если не работать с неуправляемым кодом можно задать LayoutKind.Auto для повышения производительности для структур
	- Или использовать <span style="color:#7EFFDB;font-weight:bold;">осторожно</span> LayoutKind.Explicit и задавать смещение полей с помощью FieldOffset (Не допускается перекрытие значимого и ссылочного типа)

<span style="color:HotPink;font-weight:bold;">Упаковка и распаковка</span>

- Что происходит при упаковке
	- Выделяется память в куче под значимый тип и 2 поля - указатель на объект-тип, и индекс блока синхронизации
	- Копируются поля значимого типа в кучу
	- Возвращается адрес объекта
- Что происходит при распаковке
	- Извлекается адрес полей
	- Копирование полей из кучи в значимый тип
- Приведение типов 
	- Если ссылка указывает на объект,не являющийся упакованным значением, генерируется исключение InvalidCastException
	- Нельзя взять упакованный int и привести его к типу short 
		```cs
		public static void Main() 
		{ 
			Int32 x = 5; 
			Object o = x; // Упаковка x; o указывает на упакованный объект 
			Int16 y = (Int16)(Int32) o; // Распаковка, а затем приведение типа 
		}
		```
- Изменение упакованного типа
	- Чтобы изменить упакованный тип его необходимо распоковать и имзенить
	- Далее изменный значимый тип необходимо заново упаковать 
		```cs
		// пример показывает что изменение не влияет,на упакованный тип
		public interface IGetValue  
		{  
		    public int GetValue();  
		}  
		public struct Some : IGetValue  
		{  
		    public int Value { get; set; }  
		    public int GetValue()  
		    {        return Value;  
		    }  
		}  
		static void Main(string[] args)  
		{  
		    Some s = new Some{ Value = 45 };  
		    IGetValue get = s;  
		    Console.WriteLine(get.GetValue()); //45 
		    s.Value = 67;// не влияет на упакованный тип
		    Console.WriteLine(get.GetValue()); //45 
		}
		```
	 - Изменить упакованный тип без распаковки и обратной упаковки если привести его к интерфейсу, в котором методы изменяют значения (приведенный пример выше вообще никак не относится к данному предложению), тогда вызов метода изменит упакованную копию значимого типа без распаковки и обратной упаковки (стр 171)
- Случаи упаковки
	- Вместе с тем вызов невиртуального унаследованного метода (такого, как GetType или MemberwiseClone) всегда требует упаковки значимого типа, так как эти методы определены в System.Object
	- Кроме того, приведение неупакованного экземпляра значимого типа к одному из интерфейсов этого типа требует, чтобы экземпляр был упакован, так как интерфейсные переменные всегда должны содержать ссылку на объект в куче
	- Без переопределения ToString() также будет происходить упаковка <span style="color:#7EFFDB;font-weight:bold;">упаковка происходит внутри ToString при вызове base.ToString у типа System.ValueType</span>

<span style="color:HotPink;font-weight:bold">Равенство и тождество объектов  </span>

- Сравнение объектов
	- Чтобы сравнить 2 объекта лучше вызывать ReferenceEquals() а не == т.к этот опрератор можно переопределить.
	- Чтобы сравнивать структуры, лучше переопределить этот метод Equals т.к он в базовой реализации использует отражение
- Реализация сравнения
	- Реализовать IEquatable`T` типобезопасный Equals
	-  В Equals вызывать типобезопасный Equals из IEquatable
	- Перегрузить операторы == и !=
	- Также переопределить метод GetHashCode()
- Реализация сравнения для сортировки
	- Для сортировки необходимо реализовать IComparable `T` (метод CompareTo) и перегрузить > < >= <=

<span style="color:HotPink;font-weight:bold">HashCode</span>

- GetHashCode
	- Вместе с методом Equals необходимо переопределить GetHashCode
	- <span style="color:#7EFFDB;font-weight:bold;">System.Collections. Hashtable, System.Collections.Generic.Dictionary и любых других коллекций требует, чтобы два равных объекта имели одинаковые значения хеш-кодов</span>
	- Значение GetHashCode не должно меняться на протежении жизни объекта, т.е. Все поля которые учавствуют в GetHashCode должны быть неизменяемы