[[CSharp/Память/Общее|Общее]]

-  Что такре RAM? 
	- Запоминающее устройство, где время доступа к данным не зависит от их положения в памяти
- Что такое неоднородная память?
	- время доступа к памяти зависит от положения на физическом носителе.
	- Это классические жесткие диски, CD- и DVD-диски и прочие устройства
- Что такое адрес?
	- Конкретное место в памяти - выражается в байтах 
- Арифметико-логическое устройство (АЛУ) 
	- Отвечает за выполение таких операций как сложение и вычитание
- Устройство управления (УУ)
	- декодирует команды программы (коды операций), прочитанные из памяти. Исходя из внутреннего описания команды, понимает, какую операцию – арифметическую или логическую – нужно выполнить и над какими данными.
- Что такое регитр?
	- часть памяти, к которой АЛУ и УУ (общее название – исполнительные устройства) могут обратиться очень быстро.
- Что такое слово?
	-  Современные компьютеры по большей части 32- или 64-разрядные, длина слова составляет соответственно 32 или 64 бит, и таков же размер регистров и т. п
- Что такое счетчик команд?
	- Нормальное выполнение программы сводится просто к увеличению адреса, хранящегося в счетчике команд, так чтобы он указывал на следующую команду.

- Что такое статическое выделение памяти?
	-  объем и точное расположение памяти должны быть известны на этапе компиляции, еще до начала выполнения программы
- Что такое регистровая машина?
	 - Машины , в которых для вычислений в арифметикологическом устройстве (АЛУ) использовались регистры
	 -  На таком компьютере мы фактически производим вычисления с регистрами. Чтобы выполнить сложение, деление или еще какую-то операцию, нужно сначала загрузить данные из памяти в подходящие регистры
- Что такое стек?
	- В современных компьютерах - часть оперативной памяти процесса
 - Что такое кадр стека?
	 - Им обозначают произвольные структурированные данные, сохраненные в стеке для определенных целей
- Что происходит при вызове метода (void) с точки зрения стека?
	- Указатель стека  увеличивается и создается кадр куда записываются :
		- Локальные переменные 
		- Адрес возврата
		- Аргументы
	 - После выполнения метода указатель уменьшается   и в итоге данные этого метода будут перезаписаны при вызове другого метода
- Что такое стековая машина?
	- В отличие от регистровой машины, в стековой машине все команды оперируют специальным стеком выражений (или стеком вычислений).
	- Регистров может вообще не быть.
	- .NET – идеальный пример стековой машины.

- Что такое указатели?
	- Это переменные, в которых хранится адрес местоположения в памяти. Проще говоря, указатель позволяет ссылаться на другие места в памяти по адресу
	- Поэтому в настоящее время мы работаем с 32- или 64-разрядными указателями.
- Что такое куча?
	- Это механизм, позволяющий получить <span style="color:#7EFFDB;font-weight:bold;">непрерывный</span>  блок памяти указанного размера (динамическое выделение)
	- Обращаться к динамически выделенной памяти можно только по указателю
- Что такое фрагментация памяти?
	- Когда (в общем) есть свободное место в памяти под объект,но <span style="color:#7EFFDB;font-weight:bold;">непрерывной</span> памяти под этот объект нет
- Сравнение стека и кучи
	- ![[стек и куча.png]]

- Что такое модификатор?
	- Модификатор модифицирует (изменяет) состояние памяти – объекты выделяются или модифицируются, а ссылки между ними изменяются
	- Модификатором можно назвать все, что имеет возможность модифицировать память – путем изменения существующих объектов или создания новых.
- Что такое распределитель?
	- Эта сущность отвечает за динамическое выделение и освобождение памяти.
		- Allocator.Allocate(amount)  – выделить указанное количество памяти.
		- Allocator.Deallocate(address) – освободить память по указанному адресу, сделав ее доступной для выделения в будущем.
- Достижимый объект <span style="color:#FFFFD2;font-weight:bold;">pointer</span> 
	- Объект называется достижимым, если существует последовательность ссылок (начинающаяся в памяти, доступной хотя бы одному модификатору) между объектами, которая приводит к данному объекту. Если объект не достижим ни одним модификатором, то его невозможно использовать, т.  е. он мертв и  может быть безопасно очищен.
	- На самом деле именно в  пограничной области между жизнеспособностью и  достижимостью происходит большинство <span style="color:#7EFFDB;font-weight:bold;">утечек</span> управляемой памяти.
- Корни 
	- Когда говорят о достижимости - начальные точки в области памяти модификатора
	- Модификатор – это просто поток (представленный потоком операционной системы), корнями могут быть: 
		- локальные переменные и аргументы подпрограмм, размещенные в стеке или в регистрах; 
		- статически выделенные объекты (например, глобальные переменные), размещенные в куче; 
		- другие внутренние структуры данных, хранящиеся в самом сборщике

- Подсчет ссылок
	- Идея состоит в хранении с каждым объектом счетчик.
	- Когда объект присваивается переменной или полю, количество ссылок на него увеличивается.
	- Если счетчик ссылок обращается в ноль, то на объект никто не ссылается, поэтому его можно освободить.
- Минусы посчета ссылок
	- Чтобы операции были потокобезопасными, необходимо включить синхронизацию со свойственными ей накладными расходами
	- Но в любом случае каждое присваивание порождает лишнюю запись в память, что крайне нежелательно. Помимо всего прочего, это может привести к неэффективному использованию кеша ЦП
	- Не работает с циклическими ссылками
- Отслеживающий сборщик мусора - применяется в .Net
	- опирается на знание глобального контекста времени жизни объекта и может принять более обоснованное решение о том, пора ли уже удалить объект 
	- Чтобы определить истинную достижимость объекта, начав с корней модификатора и рекурсивно обойдя весь граф объектов, созданных программой.
	- Пометка – на этом шаге сборщик определяет достижимость объектов в памяти и решает, какие из них можно убрать в мусор; 
	-  Сборка – на этом шаге сборщик возвращает системе память, занятую недостижимыми объектами.
- Пометка
	 - Начав с корней модификатора, сборщик обходит весь граф объектов и помечает те, которые посетил. Объекты, которые остались непомеченными в конце этого этапа, недостижимы.
- Консервативный сборщик мусора
	- Он работает без поддержи среды выполнения и поэтому не имеет информацию об объектах
	- Он пытается угадать что есть указатель и если память под него выделена он указатель уничтожает
	- Неприятности могут возникнуть при работе с плотными двоичными данными: растровыми изображениями, числами с плавающей точкой или блоками IP-адресов
- Точный сборщик мусора
	- Среда выполнения предоставляют сборщику полную информацию о размещении объекта в памяти
	- В .NET используется точный сборщик мусора
	- Начав с точно известных корней, сборщик просто просматривает память объект за объектом
	- Отслеживающий сборщик мусора использует различные алгоритмы для выявления "мусора", в то время как точный сборщик мусора требует точного знания структуры памяти и указателей.

<span style="color:HotPink;font-weight:bold;">2 подхода при работе с памятью</span>

- 1) Очистка
	- В этом подходе мертвые объекты просто помечаются как свободное пространство, которое можно повторно использовать позже
- Список свободных блоков
	- Структура данных, в которой хранится информация о свободных блоках памяти, чтобы их можно было находить быстрее. 
- Первое соответствие 
	- Метод поиск свободного блока памяти прекращается как только найден подходящий участок свободной памяти
- Лучшее соответствие 
	- Выбирает самый оптимальный участок памяти во избежания фрагментации
	- Более медленный
	
- 2) Уплотнение объектов
	- Полностью все же фрагментацию избежать не получится 
	- Объекты перемещаются таким образом, чтобы убрать пропуски, оставшиеся на месте удаленных объектов
- Простой подход к уплотнению объектов
	- Уплотнение сводится к простой последовательности операций копирования одного объекта за другим, причем мертвые объекты пропускаются
	- Предъявляются повышенные требования к объему памяти, т. к. на время перемещения нужно в два раза больше памяти, чем при нормальной работе
- Боллее сложный подход
	- Объекты сдвигаются друг к другу, так чтобы устранить промежутки между ними
	- в .NET применяется именно этот подход с очень интересной структурой данных для оптимизации
- *Транспиляция*
	- Называется компиляция исходного кода с одного языка на другой
