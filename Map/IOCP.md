<span style="color:HotPink;font-weight:bold;">IO completion ports</span>

- Примечание
	- Если запросы ввода-вывода обрабатываются так медленно, что для их обработки достаточно единственного потока, система будет пробуждать один и тот же поток, а остальные три так и не проснутся. Благодаря использованию алгоритма LIFO, страницы памяти, занятые ресурсами (такими как стек) потоков, не получающих процессорное время, могут выкачиваться из оперативной памяти в страничный файл на жестком диске и сбрасываться из кэша процессора. Так что существование множества потоков, ожидающих поступления уведомлений в порт завершения ввода-вывода, не так уж сильно снижает быстродействие. Если ожидающих потоков много, а обработанных запросов ввода-вывода мало, большинство ресурсов простаивающих потоков, скорее всего, будет выгружено в страничный файл.
- Функция GetLastError()
	- Возвращает код последней ошибки, произошедшей в текущем потоке. Каждый поток имеет свой собственный код ошибки, который устанавливается при вызове функций API, и GetLastError() возвращает код ошибки, установленный в текущем потоке.
- Overlapped 
	- Для каждой операции чтения и записи нужна своя overlapped
	```cpp
	typedef struct _OVERLAPPED {
		 DWORD Internal; // [вывод] код ошибки 
		 DWORD InternalHigh; // [вывод] число переданных байтов 
		 DWORD Offset; // [ввод] смещение в файле, младшие 32 бита 
		 DWORD OffsetHigh; // [ввод] смещение в файле, старшие 32 бита 
		 HANDLE hEvent; // [ввод] описатель события или данных 
	} OVERLAPPED, *LPOVERLAPPED;
	// инициализация пустым
	OVERLAPPED о1 = { 0 };
	```
	- `Offset` - это младшее 32-битное смещение для операций чтения/записи файлов размером до 4 ГБ.
	- `OffsetHigh` - это старшее 32-битное смещение. В случае, если вы работаете с файлами размером более 4 ГБ, вы должны использовать `Offset` для младших 32 бит и `OffsetHigh` для старших 32 бит.
	- <span style="color:#FFFFD2;font-weight:bold;">Запись или чтение файла начнется со следущего байта</span>
- Получение информации из структуры зная адрес ее элемента
	```cpp
	void CONTAINING_RECORD( address, type, field );
	```
	- `address` - указатель на поле структуры,
	- `type` - тип структуры
	- `filed` - поле на которое указывает `address`
	- Пример
		```cpp
			struct ReadData 
			{ 
				HANDLE hFile; 
				char buffer[1024]; 
				OVERLAPPED overlapped; 
			};
			// создание объекта
			ReadData* readData = new ReadData();
			// указатель на поле overlapped
			Overlapped* overptr = ...
			// или 
			LPOVERLAPPED overptr = ...
			// тот же самый объект что и readData
			ReadData* completedIOData = CONTAINING_RECORD
				(overptr,ReadData, overlapped);
				
		```
- Создание файла
	```cpp
	HANDLE CreateFile( 
		LPCTSTR lpFileName, // Имя файла или устройства 
		DWORD dwDesiredAccess, // Запрашиваемый доступ к файлу или устройству 
		DWORD dwShareMode, // Режим совместного доступа к файлу или устройству 
		LPSECURITY_ATTRIBUTES lpSecurityAttributes,// Атрибуты безопасности (может быть NULL) 
		DWORD dwCreationDisposition,// Как создавать или открывать файл 
		DWORD dwFlagsAndAttributes,// Дополнительные атрибуты файла 
		HANDLE hTemplateFile // Дескриптор файла для использования как шаблона (может быть NULL) );
	```
	 -  `dwDesiredAccess`: Этот параметр определяет запрашиваемый доступ к файлу или устройству. Это флаги доступа, такие как `GENERIC_READ` и `GENERIC_WRITE`, которые указывают на чтение и запись соответственно.
	 - `dwCreationDisposition`: Этот параметр определяет, как создавать или открывать файл. Например, вы можете указать `CREATE_NEW`, чтобы создать новый файл, или `OPEN_EXISTING`, чтобы открыть существующий файл.
	 - `dwFlagsAndAttributes`: Этот параметр определяет дополнительные атрибуты файла или устройства, такие как атрибуты архивации или временности. Для файлов, например, вы можете указать `FILE_FLAG_OVERLAPPED`, чтобы включить асинхронные операции ввода-вывода.
	 - `dwShareMode` - 0, запрещаем доступ другим процессам
	 - `lpSecurityAttributes` и `hTemplateFile` - в Null
- Чтение данных с файла
	```cpp
	BOOL ReadFile(
		HANDLE hFile, 
		LPVOID lpBuffer, 
		DWORD nNumberOfBytesToRead,
		LPDWORD lpNumberOfBytesRead, 
		LPOVERLAPPED lpOverlapped 
	);
	```
	- `hFile`: Дескриптор открытого файла, из которого будет производиться чтение.
	- `lpBuffer`: Указатель на буфер, в который будут считываться данные из файла.
	- `nNumberOfBytesToRead`: Количество байт, которое необходимо прочитать из файла.
	- `lpNumberOfBytesRead`: Указатель на переменную типа `DWORD`, в которую будет записано количество прочитанных байт. Может быть `NULL`, если информация о количестве байт не требуется.
	- `lpOverlapped`: Указатель на структуру `OVERLAPPED`, используемую для асинхронного чтения. Если `lpOverlapped` равен `NULL`, чтение будет синхронным.
	- При асинхронном чтении указатель файла игнорируется
	- <span style="color:#7EFFDB;font-weight:bold;">Когда `ReadFile` выполняет асинхронное чтение, и данные не могут быть немедленно считаны, функция возвращает `FALSE`, а функция `GetLastError` возвращает `ERROR_IO_PENDING`. В этом случае операция чтения будет завершена асинхронно, и управление возвращается вызывающей программе.</span>
	- <span style="color:#FFFFD2;font-weight:bold;">Если файл читатется синхронно когда была передана overlapped,(см. предыдущий пункт) то он читает данные с текущей позиции файла, а значит эти данные неверны относительно overlapped</span>
-  Запись данных в файл
	```cpp
	BOOL WriteFile( 
		HANDLE hFile, 
		LPCVOID lpBuffer,
		DWORD nNumberOfBytesToWrite, 
		LPDWORD lpNumberOfBytesWritten, 
		LPOVERLAPPED lpOverlapped );
	```
	- `hFile`: Дескриптор открытого файла, в который будет производиться запись данных.
	- `lpBuffer`: Указатель на буфер, содержащий данные для записи в файл.
	- `nNumberOfBytesToWrite`: Количество байт, которое необходимо записать в файл.
	- `lpNumberOfBytesWritten`: Указатель на переменную типа `DWORD`, в которую будет записано фактическое количество записанных байт. Может быть `NULL`, если информация о количестве записанных байт не требуется.
	- `lpOverlapped`: Указатель на структуру `OVERLAPPED`, используемую для асинхронной записи. Если `lpOverlapped` равен `NULL`, запись будет синхронной.
	- <span style="color:#7EFFDB;font-weight:bold;">Когда `WriteFile` выполняет асинхронную запись, и если данные не могут быть немедленно записаны, функция возвращает `FALSE`, а функция `GetLastError` возвращает `ERROR_IO_PENDING`. В этом случае операция записи будет завершена асинхронно, и управление возвращается вызывающей программе.</span>
	- <span style="color:#FFFFD2;font-weight:bold;">Если файл записывается инхронно когда была передана overlapped,(см. предыдущий пункт) то он записывает данные с текущей позиции файла, а значит эти данные неверны относительно overlapped</span>
- Создание порта 
	 ```cpp
		 HANDLE CreateIoCompletionPort( 
			HANDLE hFile, 
			HANDLE hExistingCompletionPort,
			UL0NG_PTR CompletionKey, 
			DWORD dwNumberOfConcurentThreads
		);
		```
	 - `hfile` - дескриптор файла
	 - `hExistingCompletionPort` - существующий порт (если создать то в NULL)
	 - `CompletionKey` - число идентификатор 
	 - Если порт существует то новый не создается
- Получение сообщений
	- GetQueuedCompletionStatus с помощью этой функции поток встанет в очередь и уснет до следущего сообщения или истечения таймера
	```cpp
	BOOL GetQueuedCompletionStatus( 
		HANDLE CompletionPort,
		LPDWORD lpNumberOfBytesTransferred, 
		PULONG_PTR lpCompletionKey, 
		LPOVERLAPPED *lpOverlapped, 
		DWORD dwMilliseconds );
	```
	- `CompletionPort`: Это дескриптор порта завершения ввода-вывода (IOCP), из которого ожидается получение информации об операции ввода-вывода.
	- `lpNumberOfBytesTransferred`: Указатель на переменную типа `DWORD`, в которую будет записано количество байт, успешно прочитанных или записанных в операции.
	- `lpCompletionKey`: Указатель на переменную типа `ULONG_PTR`, в которую будет записан пользовательский ключ, который был ассоциирован с файлом при его ассоциации с портом IOCP. Этот ключ может быть использован для определения контекста операции.
	-  `lpOverlapped`: Указатель на указатель на структуру `OVERLAPPED`, который будет указывать на структуру, связанную с завершенной операцией ввода-вывода.
	- `dwMilliseconds`: Максимальное время ожидания завершения операции ввода-вывода, в миллисекундах. Если операция не завершится за указанное время, функция вернет `FALSE`. Если передать значение `INFINITE`, функция будет ждать завершения операции бесконечно долго.
- Создание сообщений с файловой операцией 
	- Сообщение чтения/заиси файла автоматически ставятся в очередь если этот файл связан с данным портом и операция чтения/записи является асинхронной (возвращает FALSE а функция `GetLastError` возвращает `ERROR_IO_PENDING`)
- Создание пользовательских сообщений
	- Создание своих сообщений в портах
	```cpp
	BOOL PostQueuedCompletionStatus( 
		HANDLE hCompletionPort, 
		DWORD dwNumBytes, 
		ULONG_PTR CompletionKey, 
		OVERLAPPED* pOverlapped);
	```
	-  `CompletionPort`: Это дескриптор порта завершения ввода-вывода (IOCP), в который будет помещено сообщение.
	- `dwNumberOfBytesTransferred`: Количество байт, связанных с сообщением. Это может быть любое значение, которое приложение считает подходящим для идентификации типа события.
	- `dwCompletionKey`: Пользовательский ключ, который будет связан с сообщением. Этот ключ может быть использован при получении сообщения с помощью `GetQueuedCompletionStatus` для определения контекста сообщения или обработки определенных событий.
	- `lpOverlapped`: Указатель на структуру `OVERLAPPED`, который будет связан с сообщением. Это может быть полезно для определения дополнительных данных или контекста операции.
	- Функция `PostQueuedCompletionStatus` возвращает `TRUE` при успешном помещении сообщения в очередь порта завершения ввода-вывода, и `FALSE` в случае ошибки.